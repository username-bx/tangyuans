import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as r,o as i}from"./app-eShBGq08.js";const n={};function c(o,e){return i(),a("div",null,e[0]||(e[0]=[r('<h1 id="_5-重新学习vue3-响应式reactive" tabindex="-1"><a class="header-anchor" href="#_5-重新学习vue3-响应式reactive"><span>5. 重新学习vue3 响应式reactive</span></a></h1><h2 id="_1-rective-创建一个响应式对象" tabindex="-1"><a class="header-anchor" href="#_1-rective-创建一个响应式对象"><span>1. rective 创建一个响应式对象</span></a></h2><h2 id="_2-ref-和-reactive" tabindex="-1"><a class="header-anchor" href="#_2-ref-和-reactive"><span>2. ref 和 reactive</span></a></h2><ul><li>vue 使用 proxy API创建响应式，但是 proxy 只能代理对象。</li><li>ref 使用 defined</li><li>reactive 使用 proxy</li><li>ref 实际调用了 reactive API</li></ul><h3 id="此时产生的问题" tabindex="-1"><a class="header-anchor" href="#此时产生的问题"><span>此时产生的问题:</span></a></h3><ul><li>reactive 性能更好，应该推荐用户使用 reactive。</li><li>ref 实际调用 reactive，是不是代表：只需要 ref</li></ul><h2 id="_3-shallowreactive" tabindex="-1"><a class="header-anchor" href="#_3-shallowreactive"><span>3. shallowReactive</span></a></h2><h2 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践</span></a></h2><p>声明响应式推荐使用 ref</p><h2 id="reactive-局限性" tabindex="-1"><a class="header-anchor" href="#reactive-局限性"><span>reactive 局限性</span></a></h2><ul><li>不能声明原始值</li><li></li></ul>',11)]))}const s=t(n,[["render",c]]),v=JSON.parse('{"path":"/vue3/12-learn5.html","title":"5. 重新学习vue3 响应式reactive","lang":"zh-CN","frontmatter":{"title":"5. 重新学习vue3 响应式reactive","shortTitle":"vue3","icon":"file-code","date":"2025-11-30T00:00:00.000Z","order":12,"star":true,"tag":["vue3"],"auther":"Tang Yuan","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5. 重新学习vue3 响应式reactive\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-30T14:34:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Tang Yuan\\",\\"url\\":\\"\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/vue3/12-learn5.html"}],["meta",{"property":"og:site_name","content":"汤圆"}],["meta",{"property":"og:title","content":"5. 重新学习vue3 响应式reactive"}],["meta",{"property":"og:description","content":"5. 重新学习vue3 响应式reactive 1. rective 创建一个响应式对象 2. ref 和 reactive vue 使用 proxy API创建响应式，但是 proxy 只能代理对象。 ref 使用 defined reactive 使用 proxy ref 实际调用了 reactive API 此时产生的问题: reactive 性..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-30T14:34:03.000Z"}],["meta",{"property":"article:tag","content":"vue3"}],["meta",{"property":"article:published_time","content":"2025-11-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-30T14:34:03.000Z"}],["meta",{"name":"keywords","content":"vue3"}]],"description":"5. 重新学习vue3 响应式reactive 1. rective 创建一个响应式对象 2. ref 和 reactive vue 使用 proxy API创建响应式，但是 proxy 只能代理对象。 ref 使用 defined reactive 使用 proxy ref 实际调用了 reactive API 此时产生的问题: reactive 性..."},"git":{"createdTime":1764513243000,"updatedTime":1764513243000,"contributors":[{"name":"Benjamin","username":"Benjamin","email":"benjamin@BenjamindeMacBook-Air.local","commits":1,"url":"https://github.com/Benjamin"}]},"readingTime":{"minutes":0.53,"words":158},"filePathRelative":"vue3/12-learn5.md","excerpt":"\\n<h2>1. rective 创建一个响应式对象</h2>\\n<h2>2. ref 和 reactive</h2>\\n<ul>\\n<li>vue 使用 proxy API创建响应式，但是 proxy 只能代理对象。</li>\\n<li>ref 使用 defined</li>\\n<li>reactive 使用 proxy</li>\\n<li>ref 实际调用了 reactive API</li>\\n</ul>\\n<h3>此时产生的问题:</h3>\\n<ul>\\n<li>reactive 性能更好，应该推荐用户使用 reactive。</li>\\n<li>ref 实际调用 reactive，是不是代表：只需要 ref</li>\\n</ul>","autoDesc":true}');export{s as comp,v as data};
